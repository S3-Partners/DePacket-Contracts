// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import {IVRFCoordinatorV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// 1. register VRF subscription
// 2. add consumer into VRF subscription
// 3. consumer -> request random number
// 4. consumer -> receive random number

/**
 * @title RedPacketDistributor
 * @notice Distributes ERC20 tokens to a list of addresses based on a random number generated by Chainlink VRF.
 * @dev This contract uses Chainlink VRF to generate a random number, which is then used to distribute tokens to a list of addresses.
 * @author [Your Name]
 *
 */
contract RedPacketDistributor is VRFConsumerBaseV2Plus {
    using Address for address payable;

    uint256 public redPacketCount;
    uint256 private immutable i_subscriptionId; // Subscription ID for the Chainlink VRF service
    address private immutable i_vrfCoordinator; // Sepolia vrfCoordinator
    bytes32 private immutable i_keyHash; // Sepolia Gas LaneGas Lane
    uint32 private immutable i_callbackGasLimit; // Gas limit for the VRF callback function
    uint16 private immutable i_requestConfirmations; // Number of confirmations required for the VRF request
    uint32 private immutable i_numWords; // Number of random words to request

    struct RedPacketInfo {
        uint256 totalAmount;
        uint256 remainingAmount;
        uint256 remainingPackets;
        address erc20;
    }

    mapping(uint256 => RedPacketInfo) public redPackets;
    mapping(address => mapping(uint256 => bool)) public hasClaimed; // 每个地址是否已经领取过特定的红包

    mapping(uint256 => address) public requestToSender;
    mapping(uint256 => uint256) public requestToRedPacketId;

    event RedPacketCreated(uint256 indexed id, uint256 totalAmount, uint256 numPackets);
    event RedPacketClaimed(uint256 indexed id, address indexed claimer, uint256 amount, uint256 randomness);
    event RandomnessRequested(uint256 requestId, address roller);

    // https://docs.chain.link/vrf/v2-5/supported-networks#sepolia-testnet
    constructor(
        address vrfCoordinator,
        uint256 subscriptionId,
        bytes32 keyHash,
        uint32 callbackGasLimit,
        uint16 requestConfirmations,
        uint32 numWords
    ) VRFConsumerBaseV2Plus(vrfCoordinator) {
        i_vrfCoordinator = vrfCoordinator;
        i_subscriptionId = subscriptionId;
        i_keyHash = keyHash;
        i_callbackGasLimit = callbackGasLimit;
        i_requestConfirmations = requestConfirmations;
        i_numWords = numWords;
    }

    function createRedPacket(uint256 numPackets, address _erc20, uint256 _amount) external {
        require(_amount > 0, "RedPacket: Amount must be greater than 0");
        require(numPackets > 0, "RedPacket: Number of packets must be greater than 0");
        require(_erc20 != address(0), "RedPacket: ERC20 address cannot be zero");

        // 增加计数器
        redPacketCount++;
        uint256 id = redPacketCount;

        // 将 ERC20 代币从合约所有者转移到合约
        IERC20 token = IERC20(_erc20);
        require(token.transferFrom(msg.sender, address(this), _amount), "RedPacket: Transfer failed");

        // 创建红包信息
        RedPacketInfo storage rp = redPackets[id];
        rp.totalAmount = _amount;
        rp.remainingAmount = _amount;
        rp.remainingPackets = numPackets;
        rp.erc20 = _erc20;

        emit RedPacketCreated(id, _amount, numPackets);
    }

    function claimRedPacket(uint256 redPacketId) external returns (uint256 requestId) {
        RedPacketInfo storage rp = redPackets[redPacketId];
        require(!hasClaimed[msg.sender][redPacketId], "RedPacket: Already claimed");
        require(rp.remainingPackets > 0, "RedPacket: No packets left");

        requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: i_keyHash,
                subId: i_subscriptionId,
                requestConfirmations: i_requestConfirmations,
                callbackGasLimit: i_callbackGasLimit,
                numWords: i_numWords,
                // Set nativePayment to true to pay for VRF requests with Sepolia ETH instead of LINK
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: false}))
            })
        );
        requestToSender[requestId] = msg.sender;
        requestToRedPacketId[requestId] = redPacketId;
        emit RandomnessRequested(requestId, msg.sender);
    }

    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {
        address claimer = requestToSender[requestId];
        uint256 redPacketId = requestToRedPacketId[requestId];

        RedPacketInfo storage rp = redPackets[redPacketId];
        uint256 randomness = randomWords[0];
        uint256 amount = getRandomAmount(rp.remainingAmount, rp.remainingPackets, randomness);
        rp.remainingAmount -= amount;
        rp.remainingPackets--;
        hasClaimed[claimer][redPacketId] = true;

        IERC20 token = IERC20(rp.erc20);
        require(token.transfer(claimer, amount), "RedPacket: Transfer failed");

        emit RedPacketClaimed(redPacketId, claimer, amount, randomness);
    }

    function getRandomAmount(uint256 remainingAmount, uint256 remainingPackets, uint256 randomness)
        internal
        pure
        returns (uint256)
    {
        // 检查是否只剩一个红包
        // 如果只剩下一个红包，则直接返回剩余的所有金额。这是因为如果只剩一个红包，那么它应该包含所有剩余的金额。
        if (remainingPackets == 1) {
            return remainingAmount;
        }

        // 计算每个红包的最大金额：生成随机金额：最终结果在 1 到 maxAmount 之间。
        uint256 maxAmount = (remainingAmount / remainingPackets) * 2;
        return (randomness % maxAmount) + 1;
    }
}
